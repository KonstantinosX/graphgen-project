{"name":"GraphGen","tagline":"Efficient Graph Analytics on top of Relational Data","body":"\r\nWe are excited to make an initial beta release of GraphGen; a system\r\ntowards enabling graph analytics on top of relational datasets. GraphGen allows users to _declaratively_ specify graph extraction tasks over relational databases, visually explore the extracted graphs, and write and execute graph algorithms over them, either directly using our vertex-centric framework or using existing graph libraries like the widely used NetworkX Python library. GraphGen was demonstrated at _VLDB 2015_; For a few more details see our [demo paper](http://www.vldb.org/pvldb/vol8/p2032-xirogiannopoulos.pdf) or view the [video](https://youtu.be/GDVBLv-oedQ) that explains the main functionality of the demo and core research challenges in GraphGen. We also have a followup paper in the works so stay tuned!\r\n\r\nGraphGen currently only supports [Postgres](http://www.postgresql.org/) as the backend relational database.\r\n\r\n## This is cool, but is it really necessary?\r\nGraph analytics and graph algorithms have proven their worth time and again, having provided substantial value to various different domains like social networks, communication networks, finance, health, and many others. However if the data stored for a particular application is not geared towards some network-specific task or the application itself is not network-centric, users will logically not choose to store their data in a native graph store or in a graph format separating out Nodes and Edges. These users would likely use a conventional, mature and often more reliable relational database. Nevertheless these users may still want to apply these graph analyses onto their data in order to power their application, perhaps though building a machine learning model or just trying to figure out the inner-workings of their company by exploring their inner e-mail network etc. GraphGen is therefore built towards enabling users who have gone with the latter choice to _efficiently_ conduct their desired in-memory graph analyses on the data stored in their normalized relational databases without the need to manually go through time and money consuming ETL processes with often sub-optimal results.\r\n\r\nThrough its simplicity and intuitiveness, GraphGen _opens up_ graph analytics on any relational dataset by enabling exploration of different types of graphs that can be inferred just by inspecting the schema. If you can think of entities and relationships between them that exist in your schema, you can build a graph out of it!\r\n\r\n## Using GraphGen with Python\r\nThe easiest way to try out GraphGen is probably in Python through `graphgenpy`; a Python wrapper library for executing graph extraction queries in our custom DSL which is based on Datalog. The graphs that result from the extraction query are serialized to disk in a standard format and can then be _loaded_ into other graph libraries like [`NetworkX`](https://networkx.github.io/) for further analysis.\r\n\r\n###Installing graphgenpy\r\n\r\nTo install graphgenpy onto your system, simply download the graphgen-pkg, and run:\r\n`python setup.py install`\r\n\r\nAfter that you can immediately use graphgenpy to extract and serialize your graphs onto disk and use them as you please.\r\n\r\n__Example:__\r\n\r\nYou an use the following script to load up a toy version of the dblp dataset to play around with \r\n```python\r\nimport psycopg2\r\nfrom psycopg2.extensions import ISOLATION_LEVEL_AUTOCOMMIT\r\nimport pprint\r\nimport sys\r\n\r\nusername = \"kostasx\"; #<< postgres username\r\npassword = \"testdb\"; #<< postgres password\r\ndbname = \"testgraphgen\"; #<< change this name if you already have a valuable database with that name...I think it's safe you assume you don't\r\n\r\n# create the new test database\r\ntry:\r\n    conn = psycopg2.connect(\"dbname='postgres' user=\"+username+\" host = 'localhost' password=\"+password)\r\nexcept:\r\n    print \"I am unable to connect to Postgres.\"\r\n\r\nconn.set_isolation_level(ISOLATION_LEVEL_AUTOCOMMIT)\r\ncur = conn.cursor()\r\ncur.execute(\"DROP DATABASE \"+dbname+\";\")\r\ncur.execute(\"CREATE DATABASE \"+dbname+\";\")\r\n\r\n# connect to the newly created database\r\ntry:\r\n    conn = psycopg2.connect(\"dbname='\"+dbname+\"' user=\"+username+\" host='localhost' password=\"+password+\"\")\r\nexcept:\r\n    print \"I am unable to connect to the database\"\r\n\r\ncur = conn.cursor()\r\ntry:\r\n    authorTable = \"CREATE TABLE author (id integer NOT NULL PRIMARY KEY,name character varying(1024))\"\r\n    cur.execute(authorTable)\r\n\r\n    conference = \"CREATE TABLE conference (id integer NOT NULL PRIMARY KEY,name character varying(1024),year integer,location character varying(1024));\"\r\n    cur.execute(conference)\r\n\r\n    pub = \"CREATE TABLE publication (id integer NOT NULL PRIMARY KEY,title character varying(2048),cid integer NOT NULL REFERENCES conference(id));\"\r\n    cur.execute(pub)\r\n\r\n    authorpub = \"CREATE TABLE authorpublication (aid integer NOT NULL  REFERENCES author(id), pid integer NOT NULL REFERENCES publication(id), PRIMARY KEY(aid,pid));\"\r\n    cur.execute(authorpub)\r\n\r\n    # # execute our Query\r\n    authors = \"\"\"INSERT INTO author (id, name) VALUES\r\n        (1,'Anindya Datta'),\r\n        (2,'Heiko Schuldt'),\r\n        (3,'Sandeepan Banerjee'),\r\n        (4,'Christophe Bobineau'),\r\n        (5,'Sangyong Hwang'),\r\n        (6,'Tirthankar Lahiri'),\r\n        (7,'Evangelos Eleftheriou'),\r\n        (8,'Quan Z. Sheng'),\r\n        (9,'Egemen Tanin'),\r\n        (10,'Brandon Lloyd');\"\"\"\r\n    cur.execute(authors)\r\n\r\n    conferences = \"\"\" INSERT INTO conference (id, name,year,location) VALUES\r\n        (49,'VLDB',2014,'Hangzhou, China'),\r\n        (87,'VLDB',2015,'Kailua Kona, HI USA'),\r\n        (84,'SIGMOD',2014,'Snowbird, Utah'),\r\n        (36,'SIGMOD',2015,'Melbourne, Australia'),\r\n        (59,'CIDR',2015,'Asilomar, CA USA');\"\"\"\r\n    cur.execute(conferences)\r\n\r\n    publications = \"\"\" INSERT INTO publication (id, title,cid) VALUES\r\n        (8,'Title 1.',49),\r\n        (15,'Title 2.',87),\r\n        (25,'Title 3.',84),\r\n        (44,'Title 4.',36),\r\n        (64,'Title 5.',59);\r\n        \"\"\"\r\n    cur.execute(publications)\r\n    authorpubs = \"\"\"INSERT INTO authorpublication (aid, pid) VALUES\r\n        (1,8),\r\n        (1,64),\r\n        (1,44),\r\n        (2,8),\r\n        (3,15),\r\n        (4,15),\r\n        (5,25),\r\n        (5,44),\r\n        (6,25),\r\n        (7,25),\r\n        (7,8),\r\n        (8,44),\r\n        (9,64),\r\n        (10,64),\r\n        (10,44),\r\n        (10,8),\r\n        (3,64);\"\"\"\r\n    cur.execute(authorpubs)\r\n\r\n    conn.commit();\r\n    cur.close()\r\n    conn.close()\r\nexcept:\r\n    print \"Unexpected error:\", sys.exc_info()[0]\r\n\r\n```\r\n\r\nAfter having a dataset, using `graphgen` is simple\r\n```python\r\nfrom graphgenpy import GraphGenerator\r\nimport networkx as nx\r\n\r\ndatalogQuery = \"\"\" Nodes(ID, Name) :- Author(ID, Name). Edges(ID1, ID2) :- AuthorPublication(ID1, PubID), AuthorPublication(ID2, PubID).\"\"\"\r\n\r\n# Credentials for connecting to the database\r\ngg = GraphGenerator(\"localhost\",\"5432\",\"testgraphgen\",\"kostasx\",\"password\") #All these must be strings!!\r\n\r\n# Evaluate graph extraction query and serialize the resulting graph to disk in a standard format. Return the file's name in the FS\r\nfname = gg.generateGraph(datalogQuery,\"extracted_graph\",GraphGenerator.GRAPHML)\r\n\r\n# Load graph into NetworkX\r\nG = nx.read_graphml(fname)\r\nprint \"Graph Loaded into NetworkX! Running PageRank...\"\r\n\r\n# Run any algorithm on the graph using NetowrkX\r\nnx.pagerank(G)\r\nprint \"Done!\"\r\n```\r\n\r\n##Sounds great, but how do I write queries??\r\n\r\nWe have defined a declarative language based on _Datalog_ through which users are able to express graph extraction queries by expressing how the nodes and the edges should be projected from the database.\r\n\r\nAssume a _dblp_ database with the following tables:\r\n\r\n- Author\r\n- Publication\r\n- AuthorPub\r\n- Conference\r\n\r\n__Extract a graph where authors are connected to each other if they've published a paper together:__\r\n\r\n```java\r\n\r\nNodes(ID, Name) :- Author(ID, Name).\r\n\r\nEdges(ID1, ID2) :- AuthorPub(ID1, PubID), AuthorPub(ID2, PubID).\r\n\r\n```\r\n\r\nLet's take a look at how this query is formulated!\r\n\r\n![DBLP Schema](https://docs.google.com/drawings/d/17obOWt2DYJtX0-NwIESSK8n7fSLrcAvrsJ4fxsPqpk8/pub?w=853&h=337)\r\n\r\nThere are two different types of _atoms_ (which is Datalog for predicates or table names) that can exist on the left hand side of each query; `Nodes` and `Edges`. In the current iteration of GraphGen we are supporting properties _only_ on the `Nodes`, so no support for `Edge` properties for now. These `Node` properties can be selected from the right-hand side and listed after the `ID` in the `Nodes` arguments. Note that the ID _must_ be the first constant in the arguments. The right hand side consists of all the atoms, and the variables and predicates involved in the query.\r\n\r\nLet's break down this specific query which yields the co-authorship graph.\r\n\r\nIn the first line we are expressing how to project the Nodes in our graph. Here, the `Nodes` are selected from the `Author` table where their Id (`ID`) would be each distinct `aid` in the `Author` table (the ordering of the arguments mirrors the ordering of the attributes of an atom in its adjacent table); We are therefore creating a Node for every Author, and including the `name` attribute in the table as a Node property (aliased `Name`). **Note that the Node ID needs to be _unique_.**\r\n\r\nThe second line describes how each two `Nodes` will be connected to eachother, hence the graph's `Edges`. This line expresses that Node with `ID1` and `ID2` will be connected to each other, if there exists tuples in the AuthorPublication relation where they have the same publication id (`PubID`). **Note that `ID1` and `ID2` both have to refer to the same exact range of identifiers dictated by the ones we have given to the `Nodes` of the graph.**\r\n\r\nThe most exciting aspect about GraphGen is that by inspecting the schema users can envision various different ways that `Nodes` can be defined, as well as ways that these nodes can be connected to each other. For example from this\r\n\r\nAnother (slightly more complex) example would be using the well known _imdb_ database which amongst others includes the following tables in its schema:\r\n\r\n- cast_info : Contains all information on the cast and crew of all movies\r\n- role_type : Contains the role_ids and their names\r\n- name : Contains the names of all cast and crew of all movies\r\n\r\n__Extract a graph where actors are connected to each other if they've played in the same movie__\r\n\r\n```java\r\n\r\nNodes(id, name) :- name(id, name), cast_info(_, id , _, role_id),\r\nrole_type(role_id, role_name), role_name = \"actor\".\r\n\r\nEdges(id1, id2) :- cast_info(_, id1, movie_id),\r\ncast_info(_, id2, movie_id, role_id), role_type(role_id, role_name),\r\nrole_name = \"actor\".\r\n\r\n```\r\n\r\nThe first line creates a node for every person in the dataset that has been in a movie as an actor, and the second one creates links between these actors if they've played in the same movie together.\r\n\r\n__A few things to keep in mind__:\r\n\r\n- Think of each line of code as a single expression.\r\n- The first thing in the parameters of the _Nodes_ atoms should be the ID of the chosen node type and should be __unique__\r\n\r\n## Using GraphGen with Java\r\n\r\nGraphGen is written in Java and through it, we support space efficient in-memory analytics on the extracted graph through user defined vertex-centric programs. In order to use GraphGen in Java you need to import the GraphGen library located at :\r\n`graphgenpy/lib/GraphGen-0.0.5-SNAPSHOT-jar-with-dependencies.jar`\r\n\r\n__Example:__\r\n```java\r\n\r\n// Establish Connection to Database\r\nGraphGenerator ggen = new GraphGenerator(\"host\", \"port\", \"dbName\",\r\n    \"username\", \"password\");\r\n\r\n// Define and evaluate a single graph extraction query\r\nString datalog_query = \"...\";\r\nGraph g = ggen.generateGraph(datalog_query).get(0);\r\n\r\n// Initialize vertec-centric object\r\nVertexCentric p = new VertexCentric(g);\r\n\r\n// Define vertex-centric compute function\r\nExecutor program = new Executor(\"result_value_name\") {\r\n @Override\r\n public void compute(Vertex v, VertexCentric p) {\r\n    // implementation of compute function\r\n  }\r\n};\r\n// Begin execution\r\np.run(program);\r\n\r\n```\r\n\r\n## How Do I write vertex-centric Programs??\r\n\r\nThere are only a few things that users need to know about when writing vertex centric programs using the GraphGen framework:\r\n\r\n__1. Iterating over the current vertex's  neighbors__\r\n```java\r\n// v is the current vertex\r\nfor (Vertex e : v.getVertices(Direction.BOTH)) {\r\n  //...\r\n}\r\n```\r\n\r\n__2. Setting the value for the current vertex__\r\n```java\r\nv.setVal(...);\r\n```\r\n\r\n__3. Getting the current Superstep__\r\n```java\r\nint s = p.getSuperstep()\r\n```\r\n\r\n__4. Fetching one of the node's properties__\r\n```java\r\nint degree = v.getProperty(\"Degree\");\r\n```\r\n\r\n__5. Voting the node to a halt__\r\n```java\r\np.voteToHalt(v);\r\n```\r\n\r\n\r\n###Example of _PageRank_ Calculation using GraphGen (30 iterations)\r\n```java\r\n// Initialize vertec-centric object\r\nVertexCentric p = new VertexCentric(g);\r\n\r\n//The property id for the result will be \"PageRank\"\r\nExecutor pagerank = new Executor(\"PageRank\") {\r\n@Override\r\npublic void compute(Vertex v, VertexCentric p) {\r\n GenVertex gv = ((GenVertex) v);\r\n int degree = v.getProperty(\"Degree\");\r\n\r\n if (p.getSuperstep() == 0) {\r\n  gv.setVal(1.0 / degree); // initialize\r\n }\r\n\r\n if (p.getSuperstep() >= 1) {\r\n  double sum = 0;\r\n  for (Vertex e : v.getVertices(Direction.BOTH)) {\r\n  sum += (double) ((GenVertex) e).getPrevVal();\r\n }\r\n\r\n  double newPageRank = 0.15 / p.getNumOfVertices() + 0.85 * sum;\r\n  gv.setVal(newPageRank / degree);\r\n }\r\n\r\n if (p.getSuperstep() == 30) {\r\n  gv.setVal((double) gv.getPrevVal() * degree);\r\n  p.voteToHalt(gv);\r\n }\r\n}\r\n};\r\n\r\n//Run\r\np.run(pagerank);\r\n```","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}